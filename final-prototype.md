# Testing & Iterating on Prototypes

## What are best practices for testing high-fidelity prototypes?

- Test with realistic tasks and flows.

- Include both happy paths and edge cases.

- Observe silently and take notes on behavior, not just opinions.

- Use tools like Figma, Maze, or Useberry to track clicks and paths.

- Record sessions (with consent) to review later.

- Include diverse user types to uncover broader issues.

## How do you analyze feedback from stakeholders vs. end-users?

- Stakeholders: Focus on business goals, branding, technical feasibility.

- End-users: Focus on usability, clarity, and satisfaction.

- Identify overlaps and tensions, then prioritize based on user impact.

## What techniques help designers prioritize feedback and avoid overdesigning?

- Group feedback into themes (e.g., usability, aesthetics, flow).

- Use effort-impact matrices to assess changes.

- Stick to core user goals—don’t add features unless they solve real problems.

- Run small, fast tests before making big changes.

## How should usability testing findings influence prototype iterations?

- Prioritize changes that fix task-blocking issues first.

- Adjust layouts, wording, or flows that caused confusion.

- Don’t just fix surface-level complaints—look for root causes.

- Document what changed and retest if needed.

## How can UX designers balance design vision vs. user feedback when making iterations?

- Keep the core design principles intact, adapt the execution.

- Use feedback to refine—not override—the vision.

- Make evidence-based decisions (data + user needs).

- Align updates with long-term product goals.

## If conflicting feedback arises, how would you decide what to change?

- Identify which feedback aligns with user goals and usability.

- Prioritize feedback from actual users over internal opinions.

- Test variations (A/B testing or preference tests) to validate.

- Consider business impact and technical feasibility.

## What are the risks of iterating too much without clear direction?

- Design becomes inconsistent or overly complex.

- Wasted time on low-impact changes.

- Team confusion or decision fatigue.

- Loss of focus on the core user problem.
